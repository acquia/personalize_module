<?php

/**
 * @file
 * Tests for Personalize module.
 */

class PersonalizeTest extends DrupalWebTestCase {

  protected $adminUser;
  protected $managerUser;

  public static function getInfo() {
    return array(
      'name' => t('Personalize Tests'),
      'description' => t('Tests basic functionality of Personalize module.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test', 'personalize_blocks'));
  }

  function testAgentMachineNameGeneration() {
    $agent_name = 'Some Name$% with Disallow#d  Ch@racters';
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $this->assertEqual('some-name-with-disallow-d-ch-racters', $machine_name);
    // Test with a name greater than the max length.
    $agent_name = 'Some Name$% with Disallow#d  Ch@racters  that exceeds the max allowed  length';
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $this->assertEqual('some-name-with-disallow-d-ch-racters-that-exceeds-the-max-allowe', $machine_name);
  }

  function testPermissions() {
    // @todo test all permissions
  }

  function testAgentEdit() {
    $agent = personalize_agent_load_agent('test-agent');
    $this->assertTrue($agent instanceof PersonalizeAgentBase);
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertResponse(403);
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => 1,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    // Assert that we were redirected to the edit page for this agent.
    $this->assertFieldByName('agent_basic_info[title]');
    // Post the edit form and confirm we are redirected to the listing
    // page afterwards.
    unset($edit['agent_basic_info[machine_name]']);
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('agent'));
    $this->assertNoFieldByName('agent_basic_info[title]');
    $agent = personalize_agent_load_agent($machine_name);
    $this->assertTrue($agent instanceof PersonalizeTestAgent);
  }

  function testAgentDelete() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    $agent = $this->createTestAgent(array('agent_type' => 'test_agent'));
    $machine_name = $agent->getMachineName();
    $delete_path = "admin/structure/personalize/manage/$machine_name/delete";
    $this->drupalGet('admin/structure/personalize');
    // It should be possible to delete this agent.
    $this->assertLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(200);

    // Now add an option set.
    $option_set = array(
      'plugin' => 'block',
      'label' => $this->randomName(),
      'agent' => $machine_name,
    );
    $options = array();
    for ($j = 0; $j < 2; $j++) {
      $options[$j] = array(
        'option_label' => personalize_generate_option_label($j),
      );
    }
    $option_set['options'] = $options;
    $option_set = (object) $option_set;
    personalize_option_set_save($option_set);
    $machine_name = $agent->getMachineName();
    $this->drupalGet('admin/structure/personalize');
    // It should no longer be possible to delete this option set.
    $this->assertNoLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(403);

    // Now delete the option set.
    personalize_option_set_delete(1);

    // Set the status of the agent to running.
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_RUNNING);

    $this->drupalGet('admin/structure/personalize');
    // It still should not be possible to delete this option set.
    $this->assertNoLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(403);

    // Set the status of the agent to paused.
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_PAUSED);
    $this->drupalGet('admin/structure/personalize');
    // It should now be possible to delete this agent.
    $this->assertLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(200);
    $this->drupalPost(NULL, array(), t('Delete'));
    $this->resetAll();

    $agent_data = personalize_agent_load($machine_name);
    $this->assertNull($agent_data);
  }

  function testMultipleAgentTypes() {
    // Enable our other test module that provides an extra agent type.
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => 1,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    $agent = personalize_agent_load_agent($machine_name);
    $this->assertTrue($agent instanceof PersonalizeTestExtraAgent);

    // Now load the edit form and make sure there is no agent_type element
    // in the form.
    $this->drupalGet("admin/structure/personalize/manage/{$machine_name}/edit");
    $this->assertFieldByName('agent_basic_info[title]');
    $this->assertNoFieldByName('agent_basic_info[agent_type]');
  }

  function testEmbeddedAgentCreationFrom() {
    // First access the form as a logged in user that has access to admin
    // pages but does not have the 'manage personalized content' permission.
    $admin_user = $this->drupalCreateUser(array('access administration pages'));
    $this->drupalLogin($admin_user);
    $this->drupalGet('admin/personalize_test/form');
    $this->assertNoFieldByName('agent_select');
    $this->drupalLogout();
    // Now access the page with the 'manage personalized content' permission.
    $personalization_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($personalization_user);
    $this->drupalGet('admin/personalize_test/form');
    $this->assertFieldByName('agent_select');
    // We should now be able to select an agent from the dropdown and submit
    // the form
    $edit = array(
      'agent_select' => 'test-agent-2',
      'some_other_field' => 'ohai',
    );
    $this->drupalPost('admin/personalize_test/form', $edit, $this->getButton('Submit'));
    $this->assertText('ohai test-agent-2');

    // Now choose to add a new agent instead of selecting an existing one.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_select' => PERSONALIZE_NEW_AGENT_FORM_VALUE,
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => FALSE,
    );
    $this->drupalPost('admin/personalize_test/form', $edit, $this->getButton('Submit'));
    $this->assertText('Agent saved');
    $this->resetAll();
    if ($agent = personalize_agent_load_agent($machine_name)) {
      $this->assertTrue($agent instanceof PersonalizeTestAgent);
      $this->assertFalse($agent->useClientSideGoalDelivery());
    }
    else {
      $this->fail('Agent was not saved');
    }
  }

  /**
   * Tests personalization behavior under multiple scenarios.
   *
   * The test page accepts various arguments determining the behavior of the page
   * with regard to number of option sets output, number of goals processed and
   * whether these option sets and goals pertain to 1 agent or 2 different agents.
   * The assertions here make sure that in each case the correct js settings for
   * personalization are set on the page and the correct number of option sets
   * have been output.
   *
   * @see personalize_test_personalized_page().
   */
  function testPersonalizePage() {
    // Call the test page with no params - results in just one Option Set
    // with two options being output.
    $this->drupalGet('personalize-test/personalized-page');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $expected_agent_map = array(
      'test-agent' => array(
        'type' => 'test_agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array()
      )
    );
    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);

    // Assert that the option set has been output.
    $this->assertOptionSet('test-os-1');
    // @todo Add more tests for the option set settings info.

    // Call the test page specifying one option set with 3 option, and one
    // goal with the name 'my-goal'.
    $this->drupalGet('personalize-test/personalized-page/3/my-goal');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];

    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    $expected_goals_attained = array(
      'test-agent' => array(
        0 => array(
          'name' => 'my-goal',
          'value' => 1,
        )
      )
    );
    $this->assertEqual($expected_goals_attained, $personalize_settings['goals_attained']);

    // Assert that the option set has been output.
    $this->assertOptionSet('test-os-1', 'test-agent', 'option-A,option-B,option-C');


    // Call the test page specifying 2 Option Sets with 3 and 2 options respectively,
    // and 2 goals to process, 'my-goal' and 'other-goal'.
    $this->drupalGet('personalize-test/personalized-page/3,2/my-goal,other-goal');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];

    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    $expected_goals_attained = array(
      'test-agent' => array(
        array(
          'name' => 'my-goal',
          'value' => 1,
        ),
        array(
          'name' => 'other-goal',
          'value' => 1,
        )
      )
    );
    $this->assertEqual($expected_goals_attained, $personalize_settings['goals_attained']);

    // Assert that the option sets have been output.
    $this->assertOptionSet('test-os-1', 'test-agent', 'option-A,option-B,option-C');


    // Call the test page specifying 3 Option Sets with 3, 4 and 2 options respectively,
    // with 3 goals to process, 'my-goal', 'other-goal' and 'yag', and specifying
    // multiple agents to be used (the test page will use the first test agent for the
    // first option set and goal and the second test agent for all subsequent option sets
    // and goals).
    $this->drupalGet('personalize-test/personalized-page/3,4,2/my-goal,other-goal,yag/1');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $expected_agent_map = array(
      'test-agent' => array(
        'type' => 'test_agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array()
      ),
      'test-agent-2' => array(
        'type' => 'test_agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array()
      )
    );
    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    $expected_goals_attained = array(
      'test-agent' => array(
        array(
          'name' => 'my-goal',
          'value' => 1,
        ),
      ),
      'test-agent-2' => array(
        array(
          'name' => 'other-goal',
          'value' => 1,
        ),
        array(
          'name' => 'yag',
          'value' => 1,
        )
      )
    );
    $this->assertEqual($expected_goals_attained, $personalize_settings['goals_attained']);

    // Assert that the option sets have been output.
    $this->assertOptionSet('test-os-1', 'test-agent', 'option-A,option-B,option-C');
    $this->assertOptionSet('test-os-2', 'test-agent-2', 'option-A,option-B,option-C,option-D');
    $this->assertOptionSet('test-os-3', 'test-agent-2', 'option-A,option-B');


    // We should have an actionListeners property.
    $expected_action_listeners = array(
      'my_test_action' => array(
        array(
          'agent' => 'test-agent',
          'value' => 5
        )
      )
    );
    $this->assertEqual($expected_action_listeners, $personalize_settings['actionListeners']);
  }


  /**
   * Tests server-side triggering of goals.
   */
  function testServerSideGoal() {
    $this->drupalGet('personalize-test/goal');
    $this->assertText('The my-goal goal with value 2 was received by the test-agent-3 agent');
    // Test that goal that is set during a form submit that then redirects does
    // get sent.
    $this->drupalPost('personalize-test/goal-form', array(), t('Send Goal'));
    $this->assertText('The some-goal goal with value 4 was received by the test-agent-3 agent');
  }

  /**
   * Tests subscribing goals to actions and deleting goals.
   */
  function testGoalSubscriber() {
    // At first there should be no subscribers to the form_submit
    // action.
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertTrue(empty($subscribers));

    // Save a goal with this action and confirm it now has a subscriber.
    personalize_goal_save('test-agent', 'user_login', 3);
    $first_goal_id = db_select('personalize_campaign_goals', 'g')
      ->fields('g', array('id'))
      ->condition('action', 'user_login')
      ->condition('agent', 'test-agent')
      ->execute()
      ->fetchField();

    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertEqual(1, count($subscribers));

    // Save another goal, the action should still have one subscriber.
    personalize_goal_save('test-agent-2', 'user_login', 2);
    $second_goal_id = db_select('personalize_campaign_goals', 'g')
      ->fields('g', array('id'))
      ->condition('action', 'user_login')
      ->condition('agent', 'test-agent-2')
      ->execute()
      ->fetchField();

    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertEqual(1, count($subscribers));

    // Delete the first goal, should still be one subscriber.
    personalize_goal_delete($first_goal_id);
    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertEqual(1, count($subscribers));

    // When we delete the second goal, the action should go back to
    // having no subscribers.
    personalize_goal_delete($second_goal_id);

    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertTrue(empty($subscribers));
  }

  /**
   * Tests the personalize_ensure_unique_option_ids() function.
   */
  public function testUniqueOptionIDs() {
    // Test an array with already unique option IDs.
    $options = array(
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
    );
    $unique_options = personalize_ensure_unique_option_ids($options);
    $this->assertEqual($options, $unique_options);

    // Add a new option with the same id as an existing one.
    $options[] = array('option_id' => 'option-A', 'option_label' => 'Option C');
    $unique_options = personalize_ensure_unique_option_ids($options);
    // The new option should be renamed to option-C.
    $expected = array(
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-C', 'option_label' => 'Option C')
    );
    $this->assertEqual($expected, $unique_options);
    // Add another new option with the same id as an existing one.
    $options[] = array('option_id' => 'option-A', 'option_label' => 'Option D');
    $unique_options = personalize_ensure_unique_option_ids($options);
    // The new option should be renamed to option-C.
    $expected = array(
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-D', 'option_label' => 'Option D'),
    );
    $this->assertEqual($expected, $unique_options);

    // Now create a set of options with multiple repitiations and indexes
    // all over the place.
    $options = array(
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-D', 'option_label' => 'Option D'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-I', 'option_label' => 'Option I'),
    );
    $unique_options = personalize_ensure_unique_option_ids($options);
    // Option labels won't change be IDs should now be unique and in this
    // order.
    $expected = array(
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-E', 'option_label' => 'Option B'),
      array('option_id' => 'option-F', 'option_label' => 'Option C'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-G', 'option_label' => 'Option A'),
      array('option_id' => 'option-D', 'option_label' => 'Option D'),
      array('option_id' => 'option-H', 'option_label' => 'Option B'),
      array('option_id' => 'option-J', 'option_label' => 'Option A'),
      array('option_id' => 'option-I', 'option_label' => 'Option I'),
    );
    $this->assertEqual($expected, $unique_options);

    // Now add some IDs with invalid characters into the mix.
    array_unshift($options, array('option_id' => 'option C', 'option_label' => 'Option C'));
    $options[7] = $options[8] = array('option_id' => 'OHAI LOL', 'option_label' => 'Option D');
    $unique_options = personalize_ensure_unique_option_ids($options);

    $expected = array(
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-D', 'option_label' => 'Option C'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-E', 'option_label' => 'Option B'),
      array('option_id' => 'option-F', 'option_label' => 'Option C'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-G', 'option_label' => 'Option A'),
      array('option_id' => 'OHAI-LOL', 'option_label' => 'Option D'),
      array('option_id' => 'option-J', 'option_label' => 'Option D'),
      array('option_id' => 'option-K', 'option_label' => 'Option A'),
      array('option_id' => 'option-I', 'option_label' => 'Option I'),
    );
    $this->assertEqual($expected, $unique_options);

    // Generate option IDs from labels.
    $options = array(
      array('option_label' => 'Some Option ID'),
      // Add an option with the same label as the previous one.
      array('option_label' => 'Some Option ID'),
    );
    $unique_options = personalize_ensure_unique_option_ids($options);
    $expected = array(
      array('option_id' => 'some-option-id', 'option_label' => 'Some Option ID'),
      array('option_id' => 'option-B', 'option_label' => 'Some Option ID'),
    );
    $this->assertEqual($expected, $unique_options);
  }

  function testOptionSetLoading() {
    // Add some dummy option sets to the database.
    $option_set_values = array(
      array('agent' => 'some-agent', 'plugin' => 'type1', 'num_options' => 3),
      array('agent' => 'other-agent', 'plugin' => 'type1', 'num_options' => 2),
      array('agent' => 'some-agent', 'plugin' => 'type2', 'num_options' => 2),
      array('agent' => 'other-agent', 'plugin' => 'type2', 'num_options' => 4),
      array('agent' => 'some-agent', 'plugin' => 'type3', 'num_options' => 5),
      array('agent' => 'third-agent', 'plugin' => 'type4', 'num_options' => 3),
    );
    foreach ($option_set_values as $i => $values) {
      $option_set = array(
        'plugin' => $values['plugin'],
        'label' => 'Option Set ' . ($i + 1),
        'agent' => $values['agent'],
      );
      $options = array();
      for ($j = 0; $j < $values['num_options']; $j++) {
        $options[$j] = array(
          'option_id' => personalize_generate_option_id($j),
          'option_label' => personalize_generate_option_label($j),
        );
      }
      $option_set['options'] = $options;
      personalize_option_set_save((object) $option_set);
    }

    // First load Option Sets by type and assert that we get the correct number
    // of each type.
    $this->assertOptionSetCountByType('type1', 2);
    $this->assertOptionSetCountByType('type2', 2);
    $this->assertOptionSetCountByType('type3', 1);
    $this->assertOptionSetCountByType('type4', 1);

    // Now load Option Sets by agent name and again check that we get the right
    // number of each.
    $this->assertOptionSetCountByAgent('some-agent', 3);
    $this->assertOptionSetCountByAgent('other-agent', 2);
    $this->assertOptionSetCountByAgent('third-agent', 1);

    // The caches will now have been primed so even if we delete all of the Option
    // Sets from the db, we should be able to load all of them by their IDs or by
    // type or agent from the relevant static cache.
    db_delete('personalize_option_sets')->execute();
    // Load by IDs
    for ($i = 1; $i <= 6; $i++) {
      $os = personalize_option_set_load($i);
      $this->assertNotNull($os);
    }
    // Load by type.
    $this->assertOptionSetCountByType('type1', 2);
    $this->assertOptionSetCountByType('type2', 2);
    $this->assertOptionSetCountByType('type3', 1);
    $this->assertOptionSetCountByType('type4', 1);

    // Load by agent.
    $this->assertOptionSetCountByAgent('some-agent', 3);
    $this->assertOptionSetCountByAgent('other-agent', 2);
    $this->assertOptionSetCountByAgent('third-agent', 1);

    // Now reset the static cache and we should not have any Option Sets.
    drupal_static_reset();
    // Load by IDs and assert we get NULL for each one.
    for ($i = 0; $i < 6; $i++) {
      $os = personalize_option_set_load($i);
      $this->assertNull($os);
    }
    // Load by type and the count should be 0 for each type.
    $this->assertOptionSetCountByType('type1', 0);
    $this->assertOptionSetCountByType('type2', 0);
    $this->assertOptionSetCountByType('type3', 0);
    $this->assertOptionSetCountByType('type4', 0);

    // Load by agent and the count should be 0 for each agent
    $this->assertOptionSetCountByAgent('some-agent', 0);
    $this->assertOptionSetCountByAgent('other-agent', 0);
    $this->assertOptionSetCountByAgent('third-agent', 0);
  }

  function testMVTForms() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => 1,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    // Create 4 Option Sets for this agent.
    for ($i = 0; $i < 4; $i++) {
      $option_set = new stdClass();
      $option_set->label = $this->randomName(8);
      $option_set->plugin = 'some_type';
      $option_set->agent = $machine_name;
      $option_set->options = array(
        array('option_id' => 'option-A', 'option_label' => 'Option A'),
        array('option_id' => 'option-B', 'option_label' => 'Option B')
      );
      personalize_option_set_save($option_set);
    }

    // Try creating an MVT with just one option set.
    $mvt_label = $this->randomName();
    $mvt_machine_name = personalize_generate_machine_name($mvt_label, 'personalize_mvt_machine_name_exists');
    $edit = array();
    $edit['mvt[add][mvt_basic_info][label]'] = $mvt_label;
    $edit['mvt[add][mvt_basic_info][option_sets][]'] = array(1);

    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('mvt'));
    $this->assertText(t('You must choose at least two option sets to create a new multivariate test.'));
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertFalse($mvt);

    // Apparently we need to reset when posting to the same page twice
    // in a row.
    $this->resetAll();
    // Now try with 2 option sets.
    $edit['mvt[add][mvt_basic_info][option_sets][]'] = array(1, 2);
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('mvt'));

    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(2, count($mvt->option_sets));

    // Remove one of the option sets.
    $option_set = personalize_option_set_load(1, TRUE);
    $option_set->mvt = NULL;
    personalize_option_set_save($option_set);

    $this->resetAll();
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(1, count($mvt->option_sets));

    // Now add a different option set.
    $option_set_3 = personalize_option_set_load(3, TRUE);
    $option_set_3->mvt = $mvt_machine_name;
    personalize_option_set_save($option_set_3);

    $this->resetAll();
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(2, count($mvt->option_sets));

    $this->drupalGet("admin/structure/personalize/manage/{$machine_name}/edit");
    // Confirm that the existing MVT is listed with the two option set names.
    $option_set_2 = personalize_option_set_load(2, TRUE);
    $os_names = array($option_set_2->label, $option_set_3->label);
    $existing_mvt_listing = l('edit', "admin/structure/personalize/mvt/manage/{$mvt_machine_name}/edit");
    $this->assertRaw($existing_mvt_listing);
    // Now go to the edit page for this MVT and add another Option Set
    $edit = array(
      'mvt_basic_info[option_sets][]' => array(2,3,4)
    );

    $this->drupalPost("admin/structure/personalize/mvt/manage/{$mvt_machine_name}/edit", $edit, $this->getButton('Save'));

    $this->resetAll();
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(3, count($mvt->option_sets));
  }

  /**
   * Tests saving and deleting MVTs.
   */
  function testMVTSaveDelete() {
    // Create 4 Option Sets.
    for ($i = 0; $i < 4; $i++) {
      $option_set = new stdClass();
      $option_set->label = $this->randomName(8);
      $option_set->plugin = 'some_type';
      $option_set->agent = 'some-agent';
      $option_set->options = array(
        array('option_id' => 'option-A'),
        array('option_id' => 'option-B')
      );
      personalize_option_set_save($option_set);
    }

    // Now create an MVT and add the 4 Option Sets to it.
    $mvt = new stdClass();
    $mvt->label = 'Test Mvt';
    $mvt->agent = 'test-agent';
    // Only the array keys matter in the option_sets property.
    $mvt->option_sets = array(
      1 => 1,
      2 => 2,
    );
    personalize_mvt_save($mvt);

    // Reset all static vars and load all our option sets to
    // confirm that the first 2 have their mvt property set to
    // the new MVT while the others still have a null MVT value.
    drupal_static_reset();
    for ($i = 0; $i < 4; $i++) {
      $option_set = personalize_option_set_load($i + 1);
      if ($i < 2) {
        $this->assertEqual('test-mvt', $option_set->mvt);
      }
      else {
        $this->assertNull($option_set->mvt);
      }
    }

    // Now delete the MVT.
    personalize_mvt_delete('test-mvt');
    // Reset all static vars and load all our option sets to
    // confirm that all of them have a null MVT value.
    drupal_static_reset();
    for ($i = 0; $i < 4; $i++) {
      $option_set = personalize_option_set_load($i + 1);
      $this->assertNull($option_set->mvt);
    }
  }

  /**
   * Tests loading MVTs on a page.
   */
  function testMVTLoad() {
    $mvt = new stdClass();
    $mvt->label = 'Test Mvt';
    $mvt->agent = 'test-agent';
    $mvt->option_sets = array();
    personalize_mvt_save($mvt);

    // Call the test page specifying 3 Option Sets with 3, 4 and 2 options respectively,
    // with 1 goal to process and specifying that the option sets should form a multi-
    // variate test.
    $this->drupalGet('personalize-test/personalized-page/3,4,2/my-goal/0/test-mvt');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    // Confirm that we have settings for 3 Option Sets.
    $this->assertEqual(3, count($personalize_settings['option_sets']));
    // Confirm that the MVT settings have been loaded as expected.
    $this->assertTrue(isset($personalize_settings['mvt']));
    $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']));
    $this->assertEqual(3, count($personalize_settings['mvt']['test-mvt']['option_sets']));
    // Assert that each Option Set is represented in the MVT settings.
    $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']['option_sets']['test-os-1']));
    $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']['option_sets']['test-os-2']));
    $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']['option_sets']['test-os-3']));

    // Call the test page specifying 3 Option Sets with 3, 4 and 2 options respectively,
    // with 1 goal to process and specifying that 2 of the option sets should form a
    // multivariate test.
    $this->drupalGet('personalize-test/personalized-page/3,4,2/my-goal/0/test-mvt/2');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    // Confirm that we have settings for 3 Option Sets.
    $this->assertEqual(3, count($personalize_settings['option_sets']));
    // Confirm that the MVT contains only 2 Option Sets.
    $this->assertEqual(2, count($personalize_settings['mvt']['test-mvt']['option_sets']));
    $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']['option_sets']['test-os-1']));
    $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']['option_sets']['test-os-2']));
    $this->assertFalse(isset($personalize_settings['mvt']['test-mvt']['option_sets']['test-os-3']));
  }

  function testExplicitTargeting() {
    // Enable our other test module that provides an agent type that
    // supports explicit targeting.
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    // Create a user profile field that we can use for explicit targeting
    $field = array(
      'type' => 'list_text',
      'field_name' => 'field_test_user_field',
      'cardinality' => 1,
      'settings' => array(
        'allowed_values' => array('first_value' => 'First Value', 'second_value' => 'Second value', 'third_value' => 'Third value'),
      ),
    );
    field_create_field($field);
    $instance = array(
      'field_name' => 'field_test_user_field',
      'entity_type' => 'user',
      'label' => 'Some user field',
      'bundle' => 'user',
      'required' => TRUE,
      'settings' => array(
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'type' => 'options_select',
      ),
    );
    field_create_instance($instance);
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    $edit = array('visitor_context[]' => array('user_profile_context__test_user_field' => 'user_profile_context__test_user_field'));
    $this->drupalPost('admin/structure/personalize/manage/' . $machine_name . '/edit', $edit, $this->getButton('agent'));
    // Add a couple of option sets to the agent.
    $option_set_values = array(
      array('agent' => $machine_name, 'plugin' => 'type1', 'num_options' => 3),
      array('agent' => $machine_name, 'plugin' => 'type2', 'num_options' => 2),
    );
    foreach ($option_set_values as $i => $values) {
      $option_set = array(
        'plugin' => $values['plugin'],
        'label' => 'Option Set ' . ($i + 1),
        'agent' => $values['agent'],
      );
      $options = array();
      for ($j = 0; $j < $values['num_options']; $j++) {
        $options[$j] = array(
          'option_id' => personalize_generate_option_id($j),
          'option_label' => personalize_generate_option_label($j),
        );
      }
      $option_set['options'] = $options;
      personalize_option_set_save((object) $option_set);
    }
    $edit = array(
      'option_sets[option_set_1][options][option-A][enable_explicit_targeting]' => 1,
      'option_sets[option_set_1][options][option-A][explicit_targeting][mapping][]' => array('test_user_field--first_value'),
      'option_sets[option_set_1][options][option-A][explicit_targeting][strategy]' => 'OR',
      'option_sets[option_set_1][options][option-B][enable_explicit_targeting]' => 1,
      'option_sets[option_set_1][options][option-B][explicit_targeting][mapping][]' => array('test_user_field--second_value'),
      'option_sets[option_set_1][options][option-B][explicit_targeting][strategy]' => 'OR',
      'option_sets[option_set_1][options][option-C][enable_explicit_targeting]' => 1,
      'option_sets[option_set_1][options][option-C][explicit_targeting][mapping][]' => array('test_user_field--third_value'),
      'option_sets[option_set_1][options][option-C][explicit_targeting][strategy]' => 'OR',
    );
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", $edit, $this->getButton('option'));
    $this->resetAll();
    $option_set = personalize_option_set_load(1);
    $expected_targeting = array(
      'option-A' => array(
        'fixed_targeting' => array('test_user_field--first_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-B' => array(
        'fixed_targeting' => array('test_user_field--second_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-C' => array(
        'fixed_targeting' => array('test_user_field--third_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
    );
    $this->assertExplicitTargeting($option_set, $expected_targeting);
    // Now try assigning the same feature to more than one option
    $edit['option_sets[option_set_1][options][option-C][explicit_targeting][mapping][]'] = array('test_user_field--second_value');
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", $edit, $this->getButton('option'));
    $this->resetAll();
    $option_set = personalize_option_set_load(1);
    $expected_targeting = array(
      'option-A' => array(
        'fixed_targeting' => array('test_user_field--first_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-B' => array(
        'fixed_targeting' => array('test_user_field--second_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-C' => array(
        'fixed_targeting' => array(),
        'fixed_targeting_strategy' => 'OR'
      ),
    );
    $this->assertExplicitTargeting($option_set, $expected_targeting);

    // Now let's uncheck "enable_explicit_targeting" for first option
    $edit['option_sets[option_set_1][options][option-A][enable_explicit_targeting]'] = FALSE;
    $edit['option_sets[option_set_1][options][option-C][explicit_targeting][mapping][]'] =  array('test_user_field--third_value');
    $edit['option_sets[option_set_1][options][option-C][explicit_targeting][strategy]'] =  'OR';

    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", $edit, $this->getButton('option'));

    $this->resetAll();
    $option_set = personalize_option_set_load(1);
    $expected_targeting = array(
      'option-A' => array(
        'fixed_targeting' => array(),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-B' => array(
        'fixed_targeting' => array('test_user_field--second_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-C' => array(
        'fixed_targeting' => array('test_user_field--third_value'),
        'fixed_targeting_strategy' => 'OR'
      ),
    );
    $this->assertExplicitTargeting($option_set, $expected_targeting);
  }

  function testAgentStatus() {
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create two agents of different types.
    $first_agent_name = $this->randomName();
    $first_agent_machine_name = personalize_generate_machine_name($first_agent_name, 'personalize_agent_machine_name_exists');
    $second_agent_name = $this->randomName();
    $second_agent_machine_name = personalize_generate_machine_name($second_agent_name, 'personalize_agent_machine_name_exists');
    $agents = array(
      array(
        'label' => $first_agent_name,
        'machine_name' => $first_agent_machine_name,
        'agent_type' => 'test_agent',
      ),
      array(
        'label' => $second_agent_name,
        'machine_name' => $second_agent_machine_name,
        'agent_type' => 'test_extra_agent',
      ),
    );
    foreach ($agents as $agent) {
      $edit = array(
        'agent_basic_info[title]' => $agent['label'],
        'agent_basic_info[machine_name]' => $agent['machine_name'],
        'agent_basic_info[agent_type]' => $agent['agent_type'],
      );
      $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    }
    $time_before = time();
    // THe status of each agent should now be "not started"
    $this->assertEqual(PERSONALIZE_STATUS_NOT_STARTED, personalize_agent_get_status($first_agent_machine_name));
    $this->assertEqual(PERSONALIZE_STATUS_NOT_STARTED, personalize_agent_get_status($second_agent_machine_name));
    // Click the "start" button for the first agent.
    $html_id_first_agent = "personalize-toggle-status-{$first_agent_machine_name}-form";
    $this->drupalPost('admin/structure/personalize', array(), t('Start'), array(), array(), $html_id_first_agent);
    // No error should have been set.
    $this->assertNoText('There is a problem with this campaign and it cannot be run at this time');
    // The agent's status should now be "running".
    $this->assertEqual(PERSONALIZE_STATUS_RUNNING, personalize_agent_get_status($first_agent_machine_name));
    $this->resetAll();
    // Check the "started" time of the agent, which should now have been set.
    $time_after = time();
    $agent = personalize_agent_load($first_agent_machine_name);
    $this->assertTrue($time_before <= $agent->started && $agent->started <= $time_after);
    // Add an option set to this agent and confirm the agent is then set to paused.
    $option_set = array(
      'plugin' => 'some_type',
      'label' => 'Option Set 1',
      'agent' => $first_agent_machine_name,
    );
    $options = array();
    for ($j = 0; $j < 3; $j++) {
      $options[$j] = array(
        'option_id' => personalize_generate_option_id($j),
        'option_label' => personalize_generate_option_label($j),
      );
    }
    $option_set['options'] = $options;
    personalize_option_set_save((object) $option_set);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, personalize_agent_get_status($first_agent_machine_name));

    // Now click the start button of the second agent.
    $html_id_second_agent = "personalize-toggle-status-{$second_agent_machine_name}-form";
    $this->drupalPost('admin/structure/personalize', array(), t('Start'), array(), array(), $html_id_second_agent);
    // Its verify() method will have returned false so a message should have been set.
    $this->assertText('There is a problem with this campaign and it cannot be run at this time');
    // The agent's status should still be "not started"
    $this->assertEqual(PERSONALIZE_STATUS_NOT_STARTED, personalize_agent_get_status($second_agent_machine_name));
  }


  function testWinningOption() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    $personalized_blocks_form_state = array(
      'values' => array(
        'agent_select' => $machine_name,
        'title' => $this->randomName(),
        'blocks' => array(
          array(
            'option_label' => 'Option A',
            'option_id' => 'option-A',
            'weight' => 0,
            'bid' => 'comment_delta_recent',
            'remove' => 'remove_0',
          ),
          array(
            'option_label' => 'Option B',
            'option_id' => 'option-B',
            'weight' => 1,
            'bid' => 'system_delta_powered-by',
            'remove' => 'remove_1',
          ),
          array(
            'option_label' => 'Option C',
            'option_id' => 'option-C',
            'weight' => 2,
            'bid' => 'user_delta_online',
            'remove' => 'remove_2',
          ),
        ),
      ),
    );

    personalize_option_set_save(_personalize_blocks_convert_form_to_personalized_block($personalized_blocks_form_state));

    // Set the winning option in the first Option Set as Option C.
    $edit = array();
    $edit['option_sets[option_set_1][winner]'] = 'option-C';
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", $edit, $this->getButton('option'));
    $option_set_1 = personalize_option_set_load(1, TRUE);
    $this->assertEqual('option-C', $option_set_1->winner);

    // Now let's place the block in a region and make sure the correct js settings
    // show up when it's rendered on a page.
    $edit = array();
    $edit['blocks[personalize_blocks_1][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $option_set_settings = $settings['personalize']['option_sets'];
    // Assert that index 2 is provided as the winner in the settings.
    $this->assertEqual(2, $option_set_settings['osid-1']['winner']);
  }

  /**
   * Tests the ajax callback executor available for personalized blocks.
   *
   * This test also tests the setting of the executor setting.
   */
  function testAjaxCallbackExecutor() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);

    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Add some personalized blocks to the form.
    $personalized_blocks_form_state = array(
      'values' => array(
        'agent_select' => $machine_name,
        'title' => $this->randomName(),
        'blocks' => array(
          array(
            'option_label' => 'Option A',
            'option_id' => 'option-A',
            'weight' => 0,
            'bid' => 'comment_delta_recent',
            'remove' => 'remove_0',
          ),
          array(
            'option_label' => 'Option B',
            'option_id' => 'option-B',
            'weight' => 1,
            'bid' => 'system_delta_powered-by',
            'remove' => 'remove_1',
          ),
          array(
            'option_label' => 'Option C',
            'option_id' => 'option-C',
            'weight' => 2,
            'bid' => 'user_delta_online',
            'remove' => 'remove_2',
          ),
        ),
      ),
    );
    $option_set = personalize_option_set_save(_personalize_blocks_convert_form_to_personalized_block($personalized_blocks_form_state));
    $osid = $option_set->osid;

    // Go to the campaign edit form and verify rendering options.
    $this->drupalGet("admin/structure/personalize/manage/{$machine_name}/edit");
    $this->assertFieldByName("option_sets[option_set_{$osid}][advanced][executor]", 'show');
    $this->assertFieldByName("option_sets[option_set_{$osid}][advanced][executor]", 'callback');

    // Show should be checked by default.
    $this->assertFieldChecked("edit-option-sets-option-set-{$osid}-advanced-executor-show");

    // Now update to callback.
    $edit = array(
      "option_sets[option_set_{$osid}][advanced][executor]" => 'callback',
      "option_sets[option_set_{$osid}][advanced][label]" => $option_set->label,
    );
    $this->drupalPost(null, $edit, $this->getButton('option'));

    // Now callback should be checked.
    $this->assertFieldChecked("edit-option-sets-option-set-{$osid}-advanced-executor-callback");

    // Place these blocks on a page.
    $edit = array();
    $edit['blocks[personalize_blocks_1][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

    // Verify on page there isn't a template script tag for the option set.
    $show_pattern = '/<div class="personalize-option-set" id="personalize-osid-' . $osid . '">(\s*(<noscript>(.*?)<\/noscript>?)\s*)?\s*<script type="text\/template">/is';

    $this->drupalGet('');
    $this->assertNoPattern($show_pattern);

    // Change the rendering to show.
    $edit = array(
      "option_sets[option_set_{$osid}][advanced][executor]" => 'show',
      "option_sets[option_set_{$osid}][advanced][label]" => $option_set->label,
    );
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('option'));

    // Verify on the page there is a template script tag for the option set.
    $this->drupalGet('');
    $this->assertPattern($show_pattern);

    // Verify the JSON that would be returned for a specific choice.
    $commands = $this->drupalGetAJAX("personalize/option_set/osid-{$osid}/option-A/ajax");
    $selector = "personalize-osid-{$osid}";
    foreach ($commands as $command) {
      if ($command['command'] == 'insert') {
        $this->assertEqual($command['selector'], "#{$selector}");
        $this->assertEqual(strpos($command['data'], '<div id="' . $selector . '">'), 0, 'Response begins by replacing the selector.');
      }
    }
  }

  function testCampaignContextAjaxCallbacks() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);

    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Get the active context.
    $response = $this->drupalGetAJAX('/personalize/campaign_context/');
    $this->assertEqual($machine_name, $response['personalize_campaign'], 'The new campaign is the active personalize campaign context.');

    // Create another agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Set the active context to the new agent.
    $this->drupalGetAJAX('personalize/campaign_context/' . $machine_name);
    // Get the active context.
    $response = $this->drupalGetAJAX('personalize/campaign_context/');
    $this->assertEqual($machine_name, $response['personalize_campaign'], 'The new campaign is the active personalize campaign context.');
  }

  function testConfigurationSettings() {
    $admin_user = $this->drupalCreateUser(array('administer personalize configuration', 'access administration pages'));
    $this->drupalLogin($admin_user);
    // Set localStorage for decisions to false.
    $this->drupalPost('admin/config/content/personalize', array('personalize_use_local_caching' => FALSE), $this->getButton('config'));
    $this->drupalGet('');
    // Assert the correct setting is in the js.
    $settings = $this->drupalGetSettings();
    $this->assertFalse($settings['personalize']['caching']);
    // Set localStorage for decisions to true
    $this->drupalPost('admin/config/content/personalize', array('personalize_use_local_caching' => TRUE, 'personalize_local_caching_expiration' => 60), $this->getButton('config'));
    $this->drupalGet('');
    // Assert the correct setting is in the js.
    $settings = $this->drupalGetSettings();
    $this->assertEqual('localStorage', $settings['personalize']['caching']);
    $this->assertEqual(60, $settings['personalize']['cacheExpiration']);

    // Set localStorage for visitor context to false.
    $this->drupalPost('admin/config/content/personalize', array('personalize_cache_visitor_context' => FALSE), $this->getButton('config'));
    $this->drupalGet('');
    // Assert the correct setting is in the js.
    $settings = $this->drupalGetSettings();
    $this->assertFalse($settings['personalize']['cacheVisitorContext']);
    // Set localStorage for visitor context to true
    $this->drupalPost('admin/config/content/personalize', array('personalize_cache_visitor_context' => TRUE), $this->getButton('config'));
    $this->drupalGet('');
    // Assert the correct setting is in the js.
    $settings = $this->drupalGetSettings();
    $this->assertTrue($settings['personalize']['cacheVisitorContext']);
  }

  public function testOptionSetDecisionName() {
    $admin_user = $this->drupalCreateUser(array('manage personalized content', 'access administration pages', 'administer blocks'));
    $this->drupalLogin($admin_user);
    $agent = $this->createTestAgent(array('agent_type' => 'test_agent'));
    $agent_name = $agent->getMachineName();
    // Create two block-based option sets.
    $option_sets = array();
    $block_ids = array('comment_delta_recent', 'system_delta_powered-by', 'user_delta_online', 'user_delta_new');
    for ($i = 0; $i < 2; $i++) {
      // Each option set will have 2 options.
      $options = array(
        array('bid' => array_shift($block_ids)),
        array('bid' => array_shift($block_ids)),
      );
      $option_sets[] = $this->createOptionSet($i, array('plugin' => 'block', 'agent' => $agent_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));
    }
    // We're going to make the second option set have the same decision name as the
    // first, which will tie them together conceptually as one decision.
    $decision_name = personalize_get_decision_name_for_option_set($option_sets[0]);
    $edit = array(
      "option_sets[option_set_{$option_sets[1]->osid}][advanced][decision_name]" => $decision_name
    );
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", $edit, $this->getButton('option'));
    $second_os = personalize_option_set_load($option_sets[1]->osid, TRUE);
    $this->assertEqual(PERSONALIZE_OPTION_SET_PREFIX . $option_sets[0]->osid, $second_os->decision_name);

    // Now let's place the blocks in a region and make sure the correct js settings
    // show up when they're rendered.
    $edit = array();
    $edit['blocks[personalize_blocks_1][region]'] = 'sidebar_first';
    $edit['blocks[personalize_blocks_2][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $option_set_settings = $settings['personalize']['option_sets'];
    // Assert that both blocks have the same decision name.
    $this->assertEqual($option_set_settings['osid-1']['decision_name'], $option_set_settings['osid-2']['decision_name']);

    // Change both decision names to something else. The string should be converted
    // to a machine name.
    $new_name = 'Some non-machine-readable %name';
    $edit = array(
      "option_sets[option_set_{$option_sets[0]->osid}][advanced][decision_name]" => $new_name,
      "option_sets[option_set_{$option_sets[1]->osid}][advanced][decision_name]" => $new_name
    );
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", $edit, $this->getButton('option'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $option_set_settings = $settings['personalize']['option_sets'];
    // Assert that the name was sanitized.
    $this->assertEqual('some-non-machine-readable-name', $option_set_settings['osid-1']['decision_name']);
    // Assert that both blocks have the same decision name.
    $this->assertEqual($option_set_settings['osid-1']['decision_name'], $option_set_settings['osid-2']['decision_name']);
    $set_status = personalize_agent_set_status($agent_name, PERSONALIZE_STATUS_RUNNING);
    // Confirm that there was no problem settings this agent's status to Running.
    $this->assertTrue($set_status);

    // Now change one of the option sets so that the two have different numbers of options.
    $os = personalize_option_set_load(2, TRUE);
    $os->options[] = array(
      'option_id' => 'option-C',
      'option_label' => 'Option C',
      'bid' => 'system_delta_powered-by'
    );
    personalize_option_set_save($os);

    $status = personalize_agent_get_status($agent_name);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, $status);

    // Go to the campaign page and try to set the status to running. We should get an
    // error about the number of options.
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", array(), t('Resume'));
    $this->assertText("The Option Set {$second_os->label} has 3 options but uses the decision some-non-machine-readable-name which requires 2 options");
    // Confirm that the agent is still paused.
    $status = personalize_agent_get_status($agent_name);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, $status);

    // Now add a third option to the other option set but give it a different
    // option ID.
    $os = personalize_option_set_load(1, TRUE);
    $os->options[] = array(
      'option_id' => 'my-new-option',
      'option_label' => 'Option C',
      'bid' => 'user_delta_online'
    );
    personalize_option_set_save($os);

    // Go to the campaign page and try to set the status to running. We should get an
    // error about the option IDs not being the same.
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", array(), t('Resume'));
    $this->assertText("The Option Set {$second_os->label} uses the decision some-non-machine-readable-name but has different option IDs. Option IDs cannot be changed so you will need to delete the options and recreate them.");
    // Confirm that the agent is still paused.
    $status = personalize_agent_get_status($agent_name);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, $status);
  }

  /**
   * Asserts that a wrapper div for the specified Option Set has been output.
   *
   * @param int $osid
   *   The Option Set ID.
   * @param string $agent_name
   *   The name of the agent the Option Set belongs to.
   * @param string $option_names
   *   A string of comma-separated option IDs, e.g 'option-A,option-B'.
   */
  protected function assertOptionSet($osid) {
    $elements = $this->xpath('//div[@id=:id]', array(':id' => 'personalize-' . $osid));
    $this->assertEqual(1, count($elements), 'Found one element with the specified id');
    $this->assertEqual('personalize-option-set',  $elements[0]['class']);
  }

  /**
   * Helper to assert the number of Option Sets of a given type.
   *
   * @param string $type
   *   The Option Set type to assert the count of.
   * @param int $expected_count
   *   The expected count.
   */
  protected function assertOptionSetCountByType($type, $expected_count) {
    $option_sets_by_type = personalize_option_set_load_by_type($type);
    $this->assertEqual($expected_count, count($option_sets_by_type));
  }

  /**
   * Helper to assert the number of Option Sets of a given agent.
   *
   * @param string $agent
   *   The Option Set agent to assert the count of.
   * @param int $expected_count
   *   The expected count.
   */
  protected function assertOptionSetCountByAgent($agent, $expected_count) {
    $option_sets_by_agent = personalize_option_set_load_by_agent($agent);
    $this->assertEqual($expected_count, count($option_sets_by_agent));
  }

  protected function assertExplicitTargeting($option_set, $expected) {

    $this->assertEqual(count($expected), count($option_set->options));
    foreach ($option_set->options as $option) {
      if (isset($option['fixed_targeting'])) {
        $this->assertEqual($option['fixed_targeting'], $expected[$option['option_id']]['fixed_targeting']);
        $this->assertEqual($option['fixed_targeting_strategy'], $expected[$option['option_id']]['fixed_targeting_strategy']);
      }
      else {
        $this->assertFalse(isset($expected[$option['option_id']]['fixed_targeting']));
        $this->assertFalse(isset($expected[$option['option_id']]['fixed_targeting_strategy']));
      }
    }
  }

  /**
   * Helper method to move buttons names to one place to simplify
   * it's maintaining
   *
   * Kind of Page Objects Patterns
   *
   * @param $type string
   * @return string
   */
  protected function getButton($type = '') {
    switch ($type) {
      case 'agent':
        return t('Save campaign settings');
      case 'goal':
        return t('Save goals');
      case 'option':
        return t('Save variation sets');
      case 'mvt':
        return t('Save test');
      case 'delete':
        return t('Delete');
      case 'config':
        return t('Save configuration');
      default:
        return t($type);
    }
  }

  /**
   * Help function to create and test queue creation of Personalize Agent
   *
   * @param array $data
   *  array (
   *    'name' => Agent title
   *    'machine_name' => string processed by personalize_generate_machine_name()
   *  )
   * @param bool $cleanQueue Clean or not Drupal queue after 'saveAgent' queue testing
   * @return NULL|PersonalizeAgentInterface
   *
   * @see personalize_generate_machine_name()
   * @see testSaveAgent()
   */
  protected function createTestAgent($data = array()) {
    $data += array(
      'name' => $this->randomName(),
    );

    $data += array('machine_name' => personalize_generate_machine_name($data['name'], 'personalize_agent_machine_name_exists'));

    $edit = array(
      'agent_basic_info[title]' => $data['name'],
      'agent_basic_info[machine_name]' => $data['machine_name'],
      'agent_basic_info[agent_type]' => $data['agent_type'],
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    $agent = personalize_agent_load_agent($data['machine_name'], TRUE);
    $this->assertTrue($agent instanceof PersonalizeTestAgent);

    return $agent;
  }

  protected function createOptionSet($index, $option_set) {
    if (!isset($option_set['label'])) {
      $option_set['label'] = 'Option Set ' . ($index + 1);
    }

    foreach ($option_set['options'] as $i => &$option) {
      if (!isset($option['option_id'])) {
        $option['option_id'] = personalize_generate_option_id($i);
      }
      if (!isset($option['option_label'])) {
        $option['option_label'] = personalize_generate_option_label($i);
      }
    }

    $option_set = (object) $option_set;
    personalize_option_set_save($option_set);
    return $option_set;
  }
}
